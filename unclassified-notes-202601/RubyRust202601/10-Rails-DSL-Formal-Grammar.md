# Rails Model DSL: Formal Grammar Specification

## Date: 2026-02-06

## Purpose

This document formally specifies the Rails ActiveRecord model DSL as a language. The goal is to define exactly what inputs the compiler accepts, enabling precise parsing and code generation.

**Key Insight**: The Rails model DSL is a domain-specific language embedded in Ruby. While it appears to be Ruby code, it is actually a declarative specification of:
- Database schema mapping
- Relational algebra (associations as relationships)
- Constraints (validations)
- Lifecycle hooks (callbacks)
- Derived attributes (enums, store accessors)

The Ruby syntax is the host language, but the semantics are relational and declarative.

---

## Document Structure

1. **DSL Categories** — The 8 major categories of model DSL methods
2. **Grammar Productions** — EBNF specification for each category
3. **Option Tables** — Complete enumeration of valid options per method
4. **Implicit Effects** — Side effects generated by each DSL call
5. **Non-CFG Patterns** — Patterns requiring context-sensitive analysis
6. **Compilability Matrix** — Which patterns map to Rust, and how

---

## 1. DSL Categories

The Rails model DSL consists of 8 distinct categories of class-level method calls:

| Category | Purpose | Core Methods |
|----------|---------|--------------|
| **Associations** | Define relationships between models | `belongs_to`, `has_one`, `has_many`, `has_and_belongs_to_many`, `delegated_type` |
| **Validations** | Define data integrity constraints | `validates`, `validates_*`, `validate` |
| **Callbacks** | Define lifecycle hooks | `before_*`, `after_*`, `around_*` |
| **Enums** | Define enumerated column values | `enum` |
| **Scopes** | Define reusable query fragments | `scope`, `default_scope` |
| **Store Accessors** | Define JSON/serialized column accessors | `store`, `store_accessor` |
| **Nested Attributes** | Define nested form handling | `accepts_nested_attributes_for` |
| **Serialization** | Define column serialization | `serialize`, `attribute` |

---

## 2. EBNF Grammar Specification

### 2.1 Top-Level Model Definition

```ebnf
model_definition = class_declaration , model_body ;

class_declaration = "class" , model_name , "<" , parent_class ;

parent_class = "ApplicationRecord"
             | "ActiveRecord::Base"
             | model_name ;  (* STI inheritance *)

model_body = { dsl_statement } ;

dsl_statement = association_statement
              | validation_statement
              | callback_statement
              | enum_statement
              | scope_statement
              | store_statement
              | nested_attributes_statement
              | serialization_statement
              | method_definition ;
```

### 2.2 Association Grammar

```ebnf
association_statement = belongs_to_stmt
                      | has_one_stmt
                      | has_many_stmt
                      | has_and_belongs_to_many_stmt
                      | delegated_type_stmt ;

(* ═══════════════════════════════════════════════════════════════ *)
(* BELONGS_TO                                                       *)
(* ═══════════════════════════════════════════════════════════════ *)

belongs_to_stmt = "belongs_to" , association_name , [ belongs_to_options ] ;

belongs_to_options = "," , option_hash ;

belongs_to_option = class_name_opt
                  | foreign_key_opt
                  | foreign_type_opt
                  | primary_key_opt
                  | dependent_opt_belongs
                  | counter_cache_opt
                  | polymorphic_opt
                  | validate_opt
                  | autosave_opt
                  | touch_opt
                  | inverse_of_opt
                  | optional_opt
                  | required_opt
                  | default_opt
                  | strict_loading_opt
                  | query_constraints_opt ;

(* ═══════════════════════════════════════════════════════════════ *)
(* HAS_ONE                                                          *)
(* ═══════════════════════════════════════════════════════════════ *)

has_one_stmt = "has_one" , association_name , [ has_one_options ] ;

has_one_option = class_name_opt
               | dependent_opt_has
               | foreign_key_opt
               | foreign_type_opt
               | primary_key_opt
               | as_opt
               | through_opt
               | disable_joins_opt
               | source_opt
               | source_type_opt
               | validate_opt
               | autosave_opt
               | inverse_of_opt
               | strict_loading_opt
               | touch_opt
               | query_constraints_opt ;

(* ═══════════════════════════════════════════════════════════════ *)
(* HAS_MANY                                                         *)
(* ═══════════════════════════════════════════════════════════════ *)

has_many_stmt = "has_many" , association_name , [ has_many_options ] , [ has_many_block ] ;

has_many_option = class_name_opt
                | foreign_key_opt
                | foreign_type_opt
                | primary_key_opt
                | dependent_opt_has_many
                | counter_cache_opt
                | as_opt
                | through_opt
                | disable_joins_opt
                | source_opt
                | source_type_opt
                | validate_opt
                | autosave_opt
                | inverse_of_opt
                | extend_opt
                | strict_loading_opt
                | index_errors_opt
                | before_add_opt
                | after_add_opt
                | before_remove_opt
                | after_remove_opt
                | query_constraints_opt ;

has_many_block = "do" , { scope_extension } , "end" ;

(* ═══════════════════════════════════════════════════════════════ *)
(* HAS_AND_BELONGS_TO_MANY                                          *)
(* ═══════════════════════════════════════════════════════════════ *)

habtm_stmt = "has_and_belongs_to_many" , association_name , [ habtm_options ] ;

habtm_option = class_name_opt
             | join_table_opt
             | foreign_key_opt
             | association_foreign_key_opt
             | validate_opt
             | autosave_opt
             | strict_loading_opt ;

(* ═══════════════════════════════════════════════════════════════ *)
(* DELEGATED_TYPE                                                   *)
(* ═══════════════════════════════════════════════════════════════ *)

delegated_type_stmt = "delegated_type" , role_name , "," , types_array , [ delegated_type_options ] ;

types_array = "%w[" , { type_name } , "]"
            | "[" , string_list , "]" ;

delegated_type_option = foreign_key_opt
                      | foreign_type_opt
                      | primary_key_opt
                      | dependent_opt_belongs ;
```

### 2.3 Validation Grammar

```ebnf
validation_statement = validates_stmt
                     | validates_helper_stmt
                     | custom_validate_stmt ;

(* ═══════════════════════════════════════════════════════════════ *)
(* VALIDATES (unified syntax)                                       *)
(* ═══════════════════════════════════════════════════════════════ *)

validates_stmt = "validates" , attribute_list , "," , validator_options ;

attribute_list = symbol , { "," , symbol } ;

validator_options = validator_option , { "," , validator_option } ;

validator_option = presence_validator
                 | absence_validator
                 | uniqueness_validator
                 | length_validator
                 | numericality_validator
                 | format_validator
                 | inclusion_validator
                 | exclusion_validator
                 | acceptance_validator
                 | confirmation_validator
                 | comparison_validator
                 | allow_nil_opt
                 | allow_blank_opt
                 | if_opt
                 | unless_opt
                 | on_opt
                 | strict_opt
                 | custom_validator ;

presence_validator = "presence:" , ( boolean | hash_options ) ;
absence_validator = "absence:" , ( boolean | hash_options ) ;

uniqueness_validator = "uniqueness:" , ( boolean | uniqueness_options ) ;
uniqueness_options = "{" , [ scope_opt ] , [ case_sensitive_opt ] , [ conditions_opt ] , [ message_opt ] , "}" ;

length_validator = "length:" , length_options ;
length_options = "{" , ( minimum_opt | maximum_opt | in_opt | is_opt ) , { "," , length_sub_opt } , "}" ;
length_sub_opt = minimum_opt | maximum_opt | too_short_opt | too_long_opt | wrong_length_opt ;

numericality_validator = "numericality:" , ( boolean | numericality_options ) ;
numericality_options = "{" , numericality_sub_opt , { "," , numericality_sub_opt } , "}" ;
numericality_sub_opt = "only_integer:" , boolean
                     | "greater_than:" , numeric_value
                     | "greater_than_or_equal_to:" , numeric_value
                     | "equal_to:" , numeric_value
                     | "less_than:" , numeric_value
                     | "less_than_or_equal_to:" , numeric_value
                     | "other_than:" , numeric_value
                     | "in:" , range
                     | "odd:" , boolean
                     | "even:" , boolean ;

format_validator = "format:" , format_options ;
format_options = "{" , ( with_opt | without_opt ) , [ message_opt ] , "}" ;
with_opt = "with:" , regex ;
without_opt = "without:" , regex ;

inclusion_validator = "inclusion:" , inclusion_options ;
exclusion_validator = "exclusion:" , exclusion_options ;
inclusion_options = "{" , "in:" , ( array | range | proc ) , [ message_opt ] , "}" ;
exclusion_options = "{" , "in:" , ( array | range | proc ) , [ message_opt ] , "}" ;

comparison_validator = "comparison:" , comparison_options ;
comparison_options = "{" , comparison_sub_opt , "}" ;
comparison_sub_opt = "greater_than:" , comparand
                   | "greater_than_or_equal_to:" , comparand
                   | "equal_to:" , comparand
                   | "less_than:" , comparand
                   | "less_than_or_equal_to:" , comparand
                   | "other_than:" , comparand ;
comparand = symbol | numeric_value | date_value ;

custom_validator = class_constant , ":" , ( boolean | hash_options ) ;

(* ═══════════════════════════════════════════════════════════════ *)
(* VALIDATES_* helpers                                              *)
(* ═══════════════════════════════════════════════════════════════ *)

validates_helper_stmt = validates_presence_stmt
                      | validates_absence_stmt
                      | validates_uniqueness_stmt
                      | validates_length_stmt
                      | validates_numericality_stmt
                      | validates_format_stmt
                      | validates_inclusion_stmt
                      | validates_exclusion_stmt
                      | validates_associated_stmt ;

validates_presence_stmt = "validates_presence_of" , attribute_list , [ common_validator_opts ] ;
validates_absence_stmt = "validates_absence_of" , attribute_list , [ common_validator_opts ] ;
validates_uniqueness_stmt = "validates_uniqueness_of" , attribute_list , [ uniqueness_opts , common_validator_opts ] ;
validates_length_stmt = "validates_length_of" , attribute_list , length_opts , [ common_validator_opts ] ;
validates_numericality_stmt = "validates_numericality_of" , attribute_list , [ numericality_opts , common_validator_opts ] ;
validates_format_stmt = "validates_format_of" , attribute_list , format_opts , [ common_validator_opts ] ;
validates_inclusion_stmt = "validates_inclusion_of" , attribute_list , inclusion_opts , [ common_validator_opts ] ;
validates_exclusion_stmt = "validates_exclusion_of" , attribute_list , exclusion_opts , [ common_validator_opts ] ;
validates_associated_stmt = "validates_associated" , association_name , [ common_validator_opts ] ;

common_validator_opts = [ "," , on_opt ] , [ "," , if_opt ] , [ "," , unless_opt ] , [ "," , message_opt ] ;

(* ═══════════════════════════════════════════════════════════════ *)
(* VALIDATE (custom method/block)                                   *)
(* ═══════════════════════════════════════════════════════════════ *)

custom_validate_stmt = "validate" , validate_target , [ common_validator_opts ] ;

validate_target = symbol                        (* method name *)
                | validator_class               (* class constant *)
                | validate_block ;              (* inline block *)

validate_block = "do" , ruby_code , "end"
               | "{" , ruby_code , "}" ;
```

### 2.4 Callback Grammar

```ebnf
callback_statement = lifecycle_callback | transaction_callback ;

(* ═══════════════════════════════════════════════════════════════ *)
(* LIFECYCLE CALLBACKS                                              *)
(* ═══════════════════════════════════════════════════════════════ *)

lifecycle_callback = callback_timing , callback_event , callback_target , [ callback_options ] ;

callback_timing = "before_" | "after_" | "around_" ;

callback_event = "initialize"
               | "find"
               | "touch"
               | "validation"
               | "save"
               | "create"
               | "update"
               | "destroy" ;

callback_target = symbol                        (* method name *)
                | symbol_list                   (* multiple methods *)
                | callback_block ;              (* inline proc/lambda *)

callback_options = [ "," , if_opt ]
                 , [ "," , unless_opt ]
                 , [ "," , on_opt ]
                 , [ "," , prepend_opt ] ;

callback_block = "do" , ruby_code , "end"
               | "{" , ruby_code , "}"
               | "->" , "{" , ruby_code , "}"
               | "->" , "(" , params , ")" , "{" , ruby_code , "}" ;

(* ═══════════════════════════════════════════════════════════════ *)
(* TRANSACTION CALLBACKS                                            *)
(* ═══════════════════════════════════════════════════════════════ *)

transaction_callback = transaction_timing , callback_target , [ transaction_callback_opts ] ;

transaction_timing = "after_commit" | "after_rollback" ;

transaction_callback_opts = [ "," , on_opt ]
                          , [ "," , if_opt ]
                          , [ "," , unless_opt ]
                          , [ "," , prepend_opt ] ;
```

### 2.5 Enum Grammar

```ebnf
enum_statement = "enum" , enum_definition ;

enum_definition = new_syntax_enum | legacy_syntax_enum ;

(* Rails 7+ syntax *)
new_syntax_enum = enum_name , "," , enum_values , [ "," , enum_options ] ;

(* Rails 6 and earlier *)
legacy_syntax_enum = enum_name , "=>" , enum_values , [ "," , enum_options ] ;

enum_name = symbol ;

enum_values = array_enum_values | hash_enum_values ;

array_enum_values = "[" , symbol , { "," , symbol } , "]"
                  | "%i[" , { identifier } , "]" ;

hash_enum_values = "{" , enum_mapping , { "," , enum_mapping } , "}" ;

enum_mapping = symbol , "=>" , ( integer | string ) ;

enum_options = [ scopes_opt ]
             , [ default_opt ]
             , [ prefix_opt ]
             , [ suffix_opt ]
             , [ instance_methods_opt ]
             , [ validate_opt ] ;

scopes_opt = "scopes:" , boolean ;
default_opt = "default:" , ( symbol | string ) ;
prefix_opt = "prefix:" , ( boolean | symbol ) ;
suffix_opt = "suffix:" , ( boolean | symbol ) ;
instance_methods_opt = "instance_methods:" , boolean ;
validate_opt = "validate:" , ( boolean | hash_options ) ;
```

### 2.6 Scope Grammar

```ebnf
scope_statement = named_scope | default_scope ;

(* ═══════════════════════════════════════════════════════════════ *)
(* NAMED SCOPE                                                      *)
(* ═══════════════════════════════════════════════════════════════ *)

named_scope = "scope" , scope_name , "," , scope_body , [ scope_extensions ] ;

scope_name = symbol ;

scope_body = lambda_scope | proc_scope ;

lambda_scope = "->" , [ lambda_params ] , "{" , relation_chain , "}" ;

lambda_params = "(" , param_list , ")" ;

proc_scope = "Proc.new" , "{" , relation_chain , "}" ;

relation_chain = relation_method , { "." , relation_method } ;

relation_method = "where" , "(" , where_args , ")"
                | "order" , "(" , order_args , ")"
                | "limit" , "(" , integer , ")"
                | "offset" , "(" , integer , ")"
                | "includes" , "(" , symbol_list , ")"
                | "joins" , "(" , joins_args , ")"
                | "left_joins" , "(" , symbol_list , ")"
                | "preload" , "(" , symbol_list , ")"
                | "eager_load" , "(" , symbol_list , ")"
                | "select" , "(" , select_args , ")"
                | "group" , "(" , group_args , ")"
                | "having" , "(" , having_args , ")"
                | "distinct" , [ "(" , boolean , ")" ]
                | "unscoped"
                | "reorder" , "(" , order_args , ")"
                | scope_name ;  (* scope composition *)

scope_extensions = "do" , { method_definition } , "end" ;

(* ═══════════════════════════════════════════════════════════════ *)
(* DEFAULT_SCOPE                                                    *)
(* ═══════════════════════════════════════════════════════════════ *)

default_scope = "default_scope" , [ default_scope_options ] , scope_body ;

default_scope_options = "," , "all_queries:" , boolean ;
```

### 2.7 Store Grammar

```ebnf
store_statement = store_decl | store_accessor_decl ;

(* ═══════════════════════════════════════════════════════════════ *)
(* STORE                                                            *)
(* ═══════════════════════════════════════════════════════════════ *)

store_decl = "store" , column_name , [ "," , store_options ] ;

column_name = symbol ;

store_options = [ accessors_opt ]
              , [ coder_opt ]
              , [ prefix_opt ]
              , [ suffix_opt ] ;

accessors_opt = "accessors:" , "[" , symbol_list , "]" ;

coder_opt = "coder:" , coder_class ;
coder_class = "JSON" | "YAML" | custom_coder ;

(* ═══════════════════════════════════════════════════════════════ *)
(* STORE_ACCESSOR                                                   *)
(* ═══════════════════════════════════════════════════════════════ *)

store_accessor_decl = "store_accessor" , column_name , "," , accessor_list , [ "," , accessor_options ] ;

accessor_list = symbol , { "," , symbol } ;

accessor_options = [ prefix_opt ] , [ suffix_opt ] ;
```

### 2.8 Nested Attributes Grammar

```ebnf
nested_attributes_statement = "accepts_nested_attributes_for" , association_list , [ "," , nested_options ] ;

association_list = symbol , { "," , symbol } ;

nested_options = [ allow_destroy_opt ]
               , [ reject_if_opt ]
               , [ limit_opt ]
               , [ update_only_opt ] ;

allow_destroy_opt = "allow_destroy:" , boolean ;

reject_if_opt = "reject_if:" , reject_value ;
reject_value = ":all_blank"
             | symbol              (* method name *)
             | proc_literal ;      (* ->{} or proc{} *)

limit_opt = "limit:" , ( integer | symbol | proc_literal ) ;

update_only_opt = "update_only:" , boolean ;
```

### 2.9 Serialization Grammar

```ebnf
serialization_statement = serialize_decl | attribute_decl ;

(* ═══════════════════════════════════════════════════════════════ *)
(* SERIALIZE                                                        *)
(* ═══════════════════════════════════════════════════════════════ *)

serialize_decl = "serialize" , column_name , [ "," , serialize_options ] ;

serialize_options = [ coder_arg ]
                  , [ type_opt ]
                  , [ comparable_opt ]
                  , [ yaml_opt ]
                  , [ default_opt ] ;

coder_arg = coder_class | "coder:" , coder_class ;

type_opt = "type:" , class_constant ;

comparable_opt = "comparable:" , boolean ;

yaml_opt = "yaml:" , yaml_options ;
yaml_options = "{" , [ permitted_classes_opt ] , [ unsafe_load_opt ] , "}" ;
permitted_classes_opt = "permitted_classes:" , "[" , class_list , "]" ;
unsafe_load_opt = "unsafe_load:" , boolean ;

(* ═══════════════════════════════════════════════════════════════ *)
(* ATTRIBUTE (ActiveModel)                                          *)
(* ═══════════════════════════════════════════════════════════════ *)

attribute_decl = "attribute" , attribute_name , [ "," , type_name ] , [ "," , attribute_options ] ;

attribute_name = symbol ;

type_name = ":string"
          | ":integer"
          | ":float"
          | ":decimal"
          | ":datetime"
          | ":date"
          | ":time"
          | ":boolean"
          | ":binary"
          | custom_type ;

attribute_options = "default:" , default_value ;

default_value = literal | proc_literal ;
```

---

## 3. Complete Option Tables

### 3.1 Association Options Matrix

| Option | `belongs_to` | `has_one` | `has_many` | `habtm` | Type |
|--------|:------------:|:---------:|:----------:|:-------:|------|
| `:class_name` | ✓ | ✓ | ✓ | ✓ | String |
| `:foreign_key` | ✓ | ✓ | ✓ | ✓ | String |
| `:foreign_type` | ✓ | ✓ | ✓ | - | String |
| `:primary_key` | ✓ | ✓ | ✓ | - | String |
| `:dependent` | ✓¹ | ✓ | ✓ | - | Symbol |
| `:counter_cache` | ✓ | - | ✓² | - | Bool/String |
| `:polymorphic` | ✓ | - | - | - | Boolean |
| `:as` | - | ✓ | ✓ | - | Symbol |
| `:through` | - | ✓ | ✓ | - | Symbol |
| `:source` | - | ✓ | ✓ | - | Symbol |
| `:source_type` | - | ✓ | ✓ | - | String |
| `:validate` | ✓ | ✓ | ✓ | ✓ | Boolean |
| `:autosave` | ✓ | ✓ | ✓ | ✓ | Boolean |
| `:inverse_of` | ✓ | ✓ | ✓ | - | Symbol/Bool |
| `:touch` | ✓ | ✓ | - | - | Bool/Symbol |
| `:optional` | ✓ | - | - | - | Boolean |
| `:required` | ✓ | - | - | - | Boolean |
| `:default` | ✓ | - | - | - | Proc |
| `:strict_loading` | ✓ | ✓ | ✓ | ✓ | Boolean |
| `:disable_joins` | - | ✓ | ✓ | - | Boolean |
| `:extend` | - | - | ✓ | - | Module/Array |
| `:join_table` | - | - | - | ✓ | String |
| `:association_foreign_key` | - | - | - | ✓ | String |
| `:before_add` | - | - | ✓ | - | Symbol/Proc |
| `:after_add` | - | - | ✓ | - | Symbol/Proc |
| `:before_remove` | - | - | ✓ | - | Symbol/Proc |
| `:after_remove` | - | - | ✓ | - | Symbol/Proc |
| `:query_constraints` | ✓ | ✓ | ✓ | - | Array |

¹ `belongs_to :dependent` accepts: `:destroy`, `:delete`, `:destroy_async`
² `has_many :counter_cache` is the column name (different from `belongs_to`)

### 3.2 Dependent Option Values

| Value | `belongs_to` | `has_one` | `has_many` | Effect |
|-------|:------------:|:---------:|:----------:|--------|
| `:destroy` | ✓ | ✓ | ✓ | Call `destroy` on associated records |
| `:destroy_async` | ✓ | ✓ | ✓ | Enqueue background job to destroy |
| `:delete` | ✓ | ✓ | - | Call `delete` (no callbacks) |
| `:delete_all` | - | - | ✓ | Call `delete_all` on collection |
| `:nullify` | - | ✓ | ✓ | Set FK to NULL |
| `:restrict_with_exception` | - | ✓ | ✓ | Raise error if associated exist |
| `:restrict_with_error` | - | ✓ | ✓ | Add error if associated exist |

### 3.3 Callback Event Matrix

| Callback | `before_` | `around_` | `after_` |
|----------|:---------:|:---------:|:--------:|
| `initialize` | - | - | ✓ |
| `find` | - | - | ✓ |
| `touch` | - | - | ✓ |
| `validation` | ✓ | - | ✓ |
| `save` | ✓ | ✓ | ✓ |
| `create` | ✓ | ✓ | ✓ |
| `update` | ✓ | ✓ | ✓ |
| `destroy` | ✓ | ✓ | ✓ |
| `commit` | - | - | ✓ |
| `rollback` | - | - | ✓ |

### 3.4 Validation Options Matrix

| Option | Purpose | Accepted Types |
|--------|---------|----------------|
| `:presence` | Not blank | `true`, `{message:, on:, if:, unless:}` |
| `:absence` | Is blank | `true`, `{message:, on:, if:, unless:}` |
| `:uniqueness` | Unique in table | `true`, `{scope:, case_sensitive:, conditions:, ...}` |
| `:length` | String length | `{minimum:, maximum:, in:, is:, ...}` |
| `:numericality` | Numeric value | `true`, `{only_integer:, greater_than:, ...}` |
| `:format` | Regex match | `{with:, without:, ...}` |
| `:inclusion` | In set | `{in:, ...}` |
| `:exclusion` | Not in set | `{in:, ...}` |
| `:acceptance` | Checkbox | `true`, `{accept:, ...}` |
| `:confirmation` | Field match | `true`, `{case_sensitive:, ...}` |
| `:comparison` | Value comparison | `{greater_than:, equal_to:, ...}` |

---

## 4. Implicit Effects

Each DSL call triggers implicit method generation. This is the "metaprogramming" that the compiler must replicate.

### 4.1 Association Implicit Effects

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ belongs_to :author                                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│ IMPLICIT COLUMN:     author_id : Integer (FK)                               │
│ IMPLICIT METHODS:                                                           │
│   • author         → returns Author or nil                                  │
│   • author=        → sets association (by object)                           │
│   • build_author   → Author.new(book_id: self.id)                          │
│   • create_author  → Author.create(book_id: self.id)                       │
│   • create_author! → Author.create!(book_id: self.id)                      │
│   • reload_author  → force reload from DB                                   │
│   • reset_author   → clear cached association                               │
│   • author_changed?      → FK changed since load                            │
│   • author_previously_changed? → FK changed in last save                    │
│   • author_previously_was → Previous FK value                               │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│ has_many :posts                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│ IMPLICIT COLUMN:     (none on this table)                                   │
│ IMPLICIT METHODS:                                                           │
│   • posts            → returns CollectionProxy                              │
│   • posts=           → replaces collection                                  │
│   • post_ids         → returns array of IDs                                 │
│   • post_ids=        → sets by IDs                                          │
│   • posts.build      → Post.new(author_id: self.id)                        │
│   • posts.create     → Post.create(author_id: self.id)                     │
│   • posts.create!    → Post.create!(author_id: self.id)                    │
│   • posts.delete     → remove from collection                               │
│   • posts.destroy    → destroy and remove                                   │
│   • posts.clear      → remove all                                           │
│   • posts.empty?     → check if empty                                       │
│   • posts.size       → count                                                │
│   • posts.find       → find within collection                               │
│   • posts.where      → scope within collection                              │
│   • posts.exists?    → check existence                                      │
│   • posts.include?   → check membership                                     │
│   • posts.reload     → force reload                                         │
│   • posts.reset      → clear cache                                          │
│   • posts << obj     → add to collection                                    │
│   • posts.concat     → add multiple                                         │
│   • posts.push       → add to collection                                    │
│   • posts.replace    → replace collection                                   │
│   • posts.distinct   → unique records                                       │
│   • [all scopes on Post] → delegated to collection                          │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Enum Implicit Effects

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ enum :status, [:draft, :published, :archived]                               │
├─────────────────────────────────────────────────────────────────────────────┤
│ IMPLICIT COLUMN:     status : Integer (0, 1, 2)                             │
│ IMPLICIT METHODS:                                                           │
│   • draft?           → status == 0                                          │
│   • published?       → status == 1                                          │
│   • archived?        → status == 2                                          │
│   • draft!           → update(status: 0)                                    │
│   • published!       → update(status: 1)                                    │
│   • archived!        → update(status: 2)                                    │
│ IMPLICIT SCOPES:                                                            │
│   • Article.draft        → where(status: 0)                                 │
│   • Article.published    → where(status: 1)                                 │
│   • Article.archived     → where(status: 2)                                 │
│   • Article.not_draft    → where.not(status: 0)                            │
│   • Article.not_published → where.not(status: 1)                           │
│   • Article.not_archived → where.not(status: 2)                            │
│ IMPLICIT CONSTANTS:                                                         │
│   • Article.statuses     → {"draft" => 0, "published" => 1, ...}           │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 Store Accessor Implicit Effects

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ store_accessor :settings, :theme, :notifications                            │
├─────────────────────────────────────────────────────────────────────────────┤
│ IMPLICIT COLUMN:     settings : TEXT/JSONB (serialized)                     │
│ IMPLICIT METHODS (per accessor):                                            │
│   • theme              → settings["theme"]                                  │
│   • theme=             → settings["theme"] = value                          │
│   • theme_changed?     → dirty tracking                                     │
│   • theme_change       → [old, new]                                         │
│   • theme_was          → previous value                                     │
│   • theme_before_last_save → value before save                              │
│   • saved_change_to_theme? → changed in last save                          │
│   • notifications      → (same pattern)                                     │
│   • notifications=                                                          │
│   • notifications_changed?                                                  │
│   • ...                                                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.4 Callback Implicit Effects

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ before_save :normalize_email                                                │
├─────────────────────────────────────────────────────────────────────────────┤
│ IMPLICIT EFFECT:                                                            │
│   • Registers :normalize_email in the callback chain                        │
│   • Called automatically during save lifecycle                              │
│   • If returns false or throws :abort, halts chain                          │
│                                                                             │
│ EXECUTION ORDER (create):                                                   │
│   1. before_validation                                                      │
│   2. after_validation                                                       │
│   3. before_save                                                            │
│   4. before_create                                                          │
│   5. [SQL INSERT]                                                           │
│   6. after_create                                                           │
│   7. after_save                                                             │
│   8. after_commit (outside transaction)                                     │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 5. Non-CFG Patterns

Some patterns in the Rails DSL require context-sensitive analysis and cannot be expressed in a context-free grammar.

### 5.1 Patterns Requiring Global Context

| Pattern | Why Not CFG | Resolution Strategy |
|---------|-------------|---------------------|
| **Polymorphic type set** | Types are determined by other models' `as:` declarations | Scan all model files OR query DB |
| **STI subclass set** | Subclasses can be in any file | Scan all model files OR query `type` column |
| **Through association chains** | Requires following FK graph | Build association graph, traverse |
| **Inverse association** | `inverse_of` resolution needs both sides | Match by FK + class name |
| **Counter cache column** | Column may be custom named | Cross-reference `belongs_to` and `has_many` |
| **Scope composition** | Scope calls other scopes by name | Resolve scope names → bodies |

### 5.2 Patterns Requiring Runtime Values

These patterns fundamentally cannot be statically analyzed:

| Pattern | Why Dynamic | Proc Embargo Resolution |
|---------|-------------|-------------------------|
| **Proc conditions** | `if: -> { arbitrary_ruby }` | Require named methods |
| **Dynamic scope bodies** | `-> { where(date: Time.now) }` | Flag for review |
| **Polymorphic constantize** | `commentable_type.constantize` | Require closed type set |
| **Callback halting** | `throw(:abort)` non-local flow | `Result<(), Abort>` return |
| **Dynamic class names** | `class_name: -> { compute }` | Reject; require static |

### 5.3 Semantic Dependencies

The grammar is syntactically context-free, but SEMANTIC validity requires:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ SYNTACTICALLY VALID:                                                        │
│   belongs_to :author, foreign_key: :user_id, class_name: 'Person'          │
│                                                                             │
│ SEMANTICALLY VALID ONLY IF:                                                 │
│   1. Column `user_id` exists in this table                                  │
│   2. Class `Person` exists and is an AR model                               │
│   3. `Person` has a primary key (or specified :primary_key)                 │
│                                                                             │
│ This is WHY the compiler needs multi-pass architecture.                     │
│ Syntax → Semantics → Code Generation                                        │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 6. Compilability Matrix

### 6.1 Association Compilability

| Pattern | Compilable | Strategy | Restriction |
|---------|:----------:|----------|-------------|
| Simple `belongs_to` | ✓ | Direct FK method | None |
| `belongs_to` with `polymorphic: true` | ✓* | Enum dispatch | Closed type set |
| `belongs_to` with custom FK | ✓ | Use specified column | None |
| `has_one` simple | ✓ | Inverse FK method | None |
| `has_one :through` | ✓ | JOIN query | None |
| `has_many` simple | ✓ | FK query + collection | None |
| `has_many :through` | ✓ | JOIN chain query | None |
| `has_many` with `:before_add` proc | ✗ | Cannot compile | Use symbol |
| `has_and_belongs_to_many` | ✓ | JOIN table query | None |
| `delegated_type` | ✓ | Enum dispatch | Already closed |

### 6.2 Validation Compilability

| Pattern | Compilable | Strategy | Restriction |
|---------|:----------:|----------|-------------|
| `presence: true` | ✓ | `.is_some()` / `.len() > 0` | None |
| `uniqueness: true` | ✓* | SQL `EXISTS` check | No `:conditions` proc |
| `length: {in: 5..100}` | ✓ | Range check | None |
| `numericality: true` | ✓ | Type is numeric | None |
| `format: {with: /\A.../}` | ✓ | `regex` crate | None |
| `inclusion: {in: [...]}` | ✓ | `match` / contains | Static array only |
| `validates :x, if: -> {...}` | ✗ | Cannot compile | Use `:method_name` |
| `validate :custom_method` | ✓ | Call method | Must be defined |

### 6.3 Callback Compilability

| Pattern | Compilable | Strategy | Restriction |
|---------|:----------:|----------|-------------|
| `before_save :method` | ✓ | Function call in chain | None |
| `before_save :m, if: :cond` | ✓ | `if self.cond() { ... }` | Symbol only |
| `before_save :m, if: -> {...}` | ✗ | Cannot compile | Use symbol |
| `after_commit :m, on: :create` | ✓ | Post-transaction hook | None |
| `around_save :m` | ✓ | Wrap with yield | None |
| Callback with `throw(:abort)` | ✓* | `Result<(), Abort>` | Must return |

### 6.4 Enum Compilability

| Pattern | Compilable | Strategy | Restriction |
|---------|:----------:|----------|-------------|
| `enum :status, [...]` | ✓ | Rust enum + methods | None |
| `enum :status, {...}` | ✓ | Rust enum + mappings | None |
| `enum ... prefix: true` | ✓ | Prefixed method names | None |
| `enum ... scopes: false` | ✓ | Skip scope generation | None |

### 6.5 Scope Compilability

| Pattern | Compilable | Strategy | Restriction |
|---------|:----------:|----------|-------------|
| `scope :name, -> { where(...) }` | ✓ | Query builder method | Static body |
| `scope :name, ->(x) { where(a: x) }` | ✓ | Parameterized query | None |
| `scope :name, -> { where(d: Date.today) }` | ✗* | Runtime value | Mark for review |
| `default_scope { ... }` | ✓ | Applied to all queries | None |
| Scope with `.merge(other)` | ✓ | Query composition | None |

---

## 7. Terminal Symbols

For completeness, here are the terminal productions:

```ebnf
(* ═══════════════════════════════════════════════════════════════ *)
(* TERMINALS                                                        *)
(* ═══════════════════════════════════════════════════════════════ *)

symbol = ":" , identifier ;
identifier = letter , { letter | digit | "_" } ;
string = '"' , { character } , '"'
       | "'" , { character } , "'" ;
integer = [ "-" ] , digit , { digit } ;
boolean = "true" | "false" ;
regex = "/" , { regex_char } , "/" , [ regex_flags ] ;
array = "[" , [ element , { "," , element } ] , "]" ;
hash = "{" , [ pair , { "," , pair } ] , "}" ;
pair = ( symbol | string ) , "=>" , value ;
proc_literal = "->" , [ "(" , params , ")" ] , "{" , ruby_code , "}"
             | "proc" , "{" , ruby_code , "}"
             | "Proc.new" , "{" , ruby_code , "}" ;
lambda_literal = "->" , [ "(" , params , ")" ] , "{" , ruby_code , "}" ;
class_constant = uppercase , { letter | digit | "_" | "::" } ;
model_name = uppercase , { letter | digit } ;
method_name = ( letter | "_" ) , { letter | digit | "_" | "?" | "!" } ;

option_hash = option , { "," , option } ;
option = symbol , ":" , value ;
value = symbol | string | integer | boolean | array | hash | proc_literal | class_constant ;
```

---

## 8. Summary

### The Rails Model DSL is a DECLARATIVE LANGUAGE

Despite being embedded in Ruby, the Rails model DSL is fundamentally declarative:

| DSL Category | Declarative Nature |
|--------------|-------------------|
| Associations | Declare relationships (relational algebra) |
| Validations | Declare constraints (integrity rules) |
| Callbacks | Declare lifecycle transitions (state machine) |
| Enums | Declare enumerated types (sum types) |
| Scopes | Declare query predicates (selection/projection) |
| Store | Declare virtual attributes (derived columns) |

### The Compiler's Job

The compiler reads these declarations and emits equivalent Rust code:

```
Rails Declaration          →    Rust Implementation
─────────────────────────────────────────────────────────
has_many :posts            →    fn posts(&self) -> Query<Post>
validates :email, ...      →    fn validate(&self) -> ValidationResult
enum :status, [...]        →    enum Status { Draft, Published, ... }
scope :active, -> {...}    →    fn active() -> Query<Self>
before_save :normalize     →    // called in save() lifecycle
```

### Grammar Classification

- **Syntax**: Context-Free (can be parsed with LL/LR parser)
- **Semantics**: Context-Sensitive (requires symbol table, FK graph)
- **Full Compilation**: Requires Multi-Pass Architecture

### The Foundation

This grammar specification is the FOUNDATION for the compiler. Without knowing exactly what syntax is valid, we cannot reliably parse Rails models. Without knowing the implicit effects, we cannot generate equivalent Rust code.

The next document (`11-Semantic-Bridge-Design.md`) will define the Rust traits and types that implement these semantics.

---

## Appendix A: Common Patterns Cheat Sheet

```ruby
# ═══════════════════════════════════════════════════════════════════════════
# ASSOCIATIONS
# ═══════════════════════════════════════════════════════════════════════════

belongs_to :author                           # Simple FK
belongs_to :author, class_name: 'User'       # Custom class
belongs_to :author, foreign_key: :user_id    # Custom FK
belongs_to :parent, class_name: 'Category'   # Self-referential
belongs_to :commentable, polymorphic: true   # Polymorphic (RESTRICTED)
belongs_to :author, optional: true           # Nullable FK

has_one :profile                             # Simple inverse
has_one :avatar, through: :profile           # Through association
has_one :avatar, dependent: :destroy         # Cascade delete

has_many :posts                              # Simple collection
has_many :posts, dependent: :destroy         # Cascade delete
has_many :posts, -> { order(:created_at) }   # Default scope
has_many :tags, through: :taggings           # M2M through join
has_many :comments, as: :commentable         # Polymorphic inverse

has_and_belongs_to_many :categories          # Simple M2M (no model)

delegated_type :entryable, types: %w[Message Comment]  # Closed polymorphic

# ═══════════════════════════════════════════════════════════════════════════
# VALIDATIONS
# ═══════════════════════════════════════════════════════════════════════════

validates :title, presence: true
validates :email, presence: true, uniqueness: true
validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
validates :age, numericality: { greater_than: 0 }
validates :status, inclusion: { in: %w[draft published] }
validates :password, length: { minimum: 8, maximum: 128 }
validates :terms, acceptance: true
validates :password, confirmation: true

validates :email, uniqueness: { scope: :account_id }
validates :slug, uniqueness: { case_sensitive: false }

# Conditional (COMPILABLE - uses symbol)
validates :company, presence: true, if: :business_account?

# Conditional (RESTRICTED - uses proc)
validates :company, presence: true, if: -> { account_type == 'business' }

# ═══════════════════════════════════════════════════════════════════════════
# CALLBACKS
# ═══════════════════════════════════════════════════════════════════════════

before_validation :normalize_email
before_save :set_defaults
before_create :generate_token
after_create :send_welcome_email
after_save :clear_cache
after_commit :notify_subscribers, on: :create
after_destroy :cleanup_files

# Conditional (COMPILABLE)
before_save :update_slug, if: :title_changed?

# Conditional (RESTRICTED)
before_save :update_slug, if: -> { title_changed? && published? }

# ═══════════════════════════════════════════════════════════════════════════
# ENUMS
# ═══════════════════════════════════════════════════════════════════════════

enum :status, [:draft, :published, :archived]
enum :status, { draft: 0, published: 1, archived: 2 }
enum :status, [:draft, :published], prefix: true
enum :status, [:draft, :published], scopes: false
enum :role, [:user, :admin], default: :user

# ═══════════════════════════════════════════════════════════════════════════
# SCOPES
# ═══════════════════════════════════════════════════════════════════════════

scope :published, -> { where(published: true) }
scope :recent, -> { order(created_at: :desc) }
scope :by_author, ->(author) { where(author: author) }
scope :featured, -> { published.where(featured: true) }  # Composition

default_scope { where(deleted: false) }
default_scope -> { where(account_id: Current.account_id) }, all_queries: true

# ═══════════════════════════════════════════════════════════════════════════
# STORE ACCESSORS
# ═══════════════════════════════════════════════════════════════════════════

store :settings, accessors: [:theme, :notifications], coder: JSON
store_accessor :settings, :theme, :language, :timezone

# ═══════════════════════════════════════════════════════════════════════════
# NESTED ATTRIBUTES
# ═══════════════════════════════════════════════════════════════════════════

accepts_nested_attributes_for :posts
accepts_nested_attributes_for :posts, allow_destroy: true
accepts_nested_attributes_for :posts, reject_if: :all_blank
accepts_nested_attributes_for :posts, limit: 10

# ═══════════════════════════════════════════════════════════════════════════
# SERIALIZATION
# ═══════════════════════════════════════════════════════════════════════════

serialize :preferences, coder: JSON
serialize :data, type: Hash, coder: YAML
attribute :processed, :boolean, default: false
```

---

## Appendix B: Version Notes

This grammar is based on Rails 7.1+ API. Notable changes from earlier versions:

- `enum` now uses `enum :name, values` syntax (Rails 7+)
- `belongs_to` requires `optional: true` for nullable (Rails 5+)
- `delegated_type` added (Rails 6.1+)
- `default_scope` requires block/lambda (Rails 7+)
- `store` supports prefix/suffix (Rails 6+)
