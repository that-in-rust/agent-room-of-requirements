# Semantic Bridge Design: The `activerust` Crate

## Date: 2026-02-06

## Purpose

This document specifies the design of `activerust`, a Rust crate that provides Rails-compatible semantics for compiled Rails applications. The crate bridges the semantic gap between Rails' runtime behavior and Rust's compile-time guarantees.

**The Core Problem**: Rails semantics include runtime behaviors (dirty tracking, callbacks, validations, lazy loading) that don't exist natively in Rust ORMs like Diesel or SeaORM. The compiler must emit code that uses traits providing these semantics.

**The Solution**: A standalone `activerust` crate that can be used:
1. By the compiler's generated code
2. By developers manually porting Rails applications
3. As an independent "Rails-like" Rust framework

---

## Design Principles

### 1. Trait-Based Extension

Following Rust idioms, all behavior is added via traits. A plain Diesel/SeaORM struct gains Rails semantics by implementing `activerust` traits.

### 2. Zero-Cost Abstractions Where Possible

Validations, enums, and simple callbacks compile to static function calls. Only truly dynamic patterns (lazy loading, runtime dirty tracking) incur runtime cost.

### 3. Explicit Over Implicit

Unlike Rails' magic, `activerust` makes everything explicit:
- Dirty tracking requires `#[derive(DirtyTracking)]` or manual `changes()` calls
- Callbacks are functions in a chain, not hidden hooks
- Associations are explicit methods, not `method_missing`

### 4. Compatibility with Existing ORMs

`activerust` wraps Diesel, SeaORM, or SQLx — it doesn't replace them. Database operations go through the underlying ORM.

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         APPLICATION CODE                                     │
│  (Generated by compiler OR hand-written)                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                           activerust                                         │
│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐   │
│  │ DirtyTracking │ │   Callbacks   │ │  Validatable  │ │ Associations  │   │
│  └───────────────┘ └───────────────┘ └───────────────┘ └───────────────┘   │
│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐   │
│  │  Persistable  │ │   Timestamps  │ │ RailsCoercion │ │  Enumerable   │   │
│  └───────────────┘ └───────────────┘ └───────────────┘ └───────────────┘   │
├─────────────────────────────────────────────────────────────────────────────┤
│                      DATABASE ADAPTER LAYER                                  │
│  ┌───────────────┐ ┌───────────────┐ ┌───────────────┐                      │
│  │    Diesel     │ │    SeaORM     │ │     SQLx      │                      │
│  └───────────────┘ └───────────────┘ └───────────────┘                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                         DATABASE                                             │
│                  PostgreSQL / MySQL / SQLite                                 │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Trait Specifications

### 1. DirtyTracking

**Purpose**: Track which attributes have changed since the record was loaded or last saved.

**Rails Equivalent**:
```ruby
user.name = "New Name"
user.name_changed?        # => true
user.name_was             # => "Old Name"
user.name_change          # => ["Old Name", "New Name"]
user.changes              # => {"name" => ["Old Name", "New Name"]}
user.changed?             # => true
user.changed_attributes   # => {"name" => "Old Name"}
```

**Rust Design**:

```rust
/// Marker for tracking state: loaded from DB vs modified
#[derive(Clone, Debug, PartialEq)]
pub enum AttributeState<T> {
    /// Value loaded from database, not modified
    Persisted(T),
    /// Value has been changed
    Changed { was: T, now: T },
    /// New record, no persisted value
    New(T),
}

/// Core trait for dirty tracking
pub trait DirtyTracking: Sized {
    type Changes: Default;

    /// Check if any attribute has changed
    fn changed(&self) -> bool;

    /// Get all changes as a map of field name -> (old, new)
    fn changes(&self) -> Self::Changes;

    /// Check if a specific attribute changed
    fn attribute_changed(&self, attr: &str) -> bool;

    /// Get the previous value of an attribute
    fn attribute_was<T>(&self, attr: &str) -> Option<T>;

    /// Get the change for an attribute: (old, new)
    fn attribute_change<T>(&self, attr: &str) -> Option<(T, T)>;

    /// Mark record as persisted (clear dirty state)
    fn mark_persisted(&mut self);

    /// Reset changes (reload from persisted values)
    fn reset_changes(&mut self);
}

/// Derive macro generates per-field tracking
///
/// ```rust
/// #[derive(DirtyTracking)]
/// struct User {
///     #[dirty_track]
///     name: String,
///     #[dirty_track]
///     email: String,
///     #[no_track]  // Excluded from tracking
///     cached_value: Option<i32>,
/// }
/// ```
```

**Generated Code Example**:

```rust
// For a User with name and email fields:

impl DirtyTracking for User {
    type Changes = UserChanges;

    fn changed(&self) -> bool {
        self._dirty.name.is_changed() || self._dirty.email.is_changed()
    }

    fn changes(&self) -> UserChanges {
        UserChanges {
            name: self._dirty.name.change(),
            email: self._dirty.email.change(),
        }
    }

    // ... other methods
}

// Per-field accessor methods (generated by derive macro):
impl User {
    pub fn name_changed(&self) -> bool {
        self._dirty.name.is_changed()
    }

    pub fn name_was(&self) -> Option<&String> {
        self._dirty.name.was()
    }

    pub fn name_change(&self) -> Option<(&String, &String)> {
        self._dirty.name.change()
    }

    // Setter that tracks changes
    pub fn set_name(&mut self, value: String) {
        self._dirty.name.set(value);
    }
}
```

---

### 2. Callbacks

**Purpose**: Execute functions before/after lifecycle events (create, update, save, destroy).

**Rails Equivalent**:
```ruby
before_validation :normalize_email
before_save :set_defaults
after_create :send_welcome_email
after_commit :notify_subscribers, on: :create
```

**Key Difference from Rails**: No `throw(:abort)` non-local control flow. Instead, callbacks return `Result<(), CallbackError>`. Any error halts the chain.

**Rust Design**:

```rust
/// Error returned by callbacks to halt the chain
#[derive(Debug, Clone)]
pub struct CallbackError {
    pub callback_name: &'static str,
    pub message: String,
}

/// Result type for callbacks
pub type CallbackResult = Result<(), CallbackError>;

/// Lifecycle events that can trigger callbacks
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LifecycleEvent {
    Initialize,
    Find,
    Touch,
    Validation,
    Save,
    Create,
    Update,
    Destroy,
    Commit,
    Rollback,
}

/// Timing of callback execution
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CallbackTiming {
    Before,
    After,
    Around,
}

/// A single callback in the chain
pub struct Callback<T> {
    pub name: &'static str,
    pub timing: CallbackTiming,
    pub event: LifecycleEvent,
    pub condition: Option<fn(&T) -> bool>,
    pub action: fn(&mut T) -> CallbackResult,
}

/// Trait for models with callbacks
pub trait Callbacks: Sized {
    /// Get the callback chain for this model
    fn callbacks() -> &'static [Callback<Self>];

    /// Run before callbacks for an event
    fn run_before_callbacks(&mut self, event: LifecycleEvent) -> CallbackResult {
        for cb in Self::callbacks() {
            if cb.timing == CallbackTiming::Before && cb.event == event {
                if let Some(cond) = cb.condition {
                    if !cond(self) {
                        continue;
                    }
                }
                (cb.action)(self)?;
            }
        }
        Ok(())
    }

    /// Run after callbacks for an event
    fn run_after_callbacks(&mut self, event: LifecycleEvent) -> CallbackResult {
        for cb in Self::callbacks() {
            if cb.timing == CallbackTiming::After && cb.event == event {
                if let Some(cond) = cb.condition {
                    if !cond(self) {
                        continue;
                    }
                }
                (cb.action)(self)?;
            }
        }
        Ok(())
    }
}

/// Macro for declaring callbacks (cleaner syntax)
///
/// ```rust
/// callbacks! {
///     User,
///     before_validation :normalize_email;
///     before_save :set_defaults, if: :should_set_defaults;
///     after_create :send_welcome_email;
///     after_commit :notify_subscribers, on: create;
/// }
/// ```
#[macro_export]
macro_rules! callbacks {
    // ... macro implementation
}
```

**Generated Code Example**:

```rust
// For User with before_save :normalize_email, if: :email_changed?

impl Callbacks for User {
    fn callbacks() -> &'static [Callback<Self>] {
        static CALLBACKS: &[Callback<User>] = &[
            Callback {
                name: "normalize_email",
                timing: CallbackTiming::Before,
                event: LifecycleEvent::Save,
                condition: Some(|u| u.email_changed()),
                action: |u| u.normalize_email(),
            },
        ];
        CALLBACKS
    }
}

impl User {
    fn normalize_email(&mut self) -> CallbackResult {
        self.email = self.email.to_lowercase().trim().to_string();
        Ok(())
    }
}
```

---

### 3. Validatable

**Purpose**: Validate model attributes before persistence.

**Rails Equivalent**:
```ruby
validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }
validates :age, numericality: { greater_than: 0 }
```

**Rust Design**:

```rust
/// A single validation error
#[derive(Debug, Clone)]
pub struct ValidationError {
    pub attribute: &'static str,
    pub message: String,
    pub code: &'static str,  // e.g., "blank", "invalid", "taken"
}

/// Collection of validation errors
#[derive(Debug, Clone, Default)]
pub struct ValidationErrors {
    pub errors: Vec<ValidationError>,
}

impl ValidationErrors {
    pub fn add(&mut self, attribute: &'static str, message: impl Into<String>, code: &'static str) {
        self.errors.push(ValidationError {
            attribute,
            message: message.into(),
            code,
        });
    }

    pub fn is_empty(&self) -> bool {
        self.errors.is_empty()
    }

    pub fn full_messages(&self) -> Vec<String> {
        self.errors.iter()
            .map(|e| format!("{} {}", e.attribute, e.message))
            .collect()
    }

    pub fn on(&self, attribute: &str) -> Vec<&ValidationError> {
        self.errors.iter()
            .filter(|e| e.attribute == attribute)
            .collect()
    }
}

/// Result type for validation
pub type ValidationResult = Result<(), ValidationErrors>;

/// Trait for validatable models
pub trait Validatable: Sized {
    /// Run all validations and return errors
    fn validate(&self) -> ValidationResult;

    /// Check if model is valid (runs validations)
    fn valid(&self) -> bool {
        self.validate().is_ok()
    }

    /// Check if model is invalid
    fn invalid(&self) -> bool {
        !self.valid()
    }

    /// Get validation errors (runs validations)
    fn errors(&self) -> ValidationErrors {
        match self.validate() {
            Ok(()) => ValidationErrors::default(),
            Err(errors) => errors,
        }
    }
}

/// Context for conditional validations
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ValidationContext {
    Create,
    Update,
    Save,
    Custom(&'static str),
}

/// Validation builder for fluent API
pub struct Validator<T> {
    model: *const T,
    errors: ValidationErrors,
    context: ValidationContext,
}

impl<T> Validator<T> {
    pub fn validates_presence(&mut self, attr: &'static str, value: &Option<impl AsRef<str>>) {
        if value.as_ref().map(|s| s.as_ref().is_empty()).unwrap_or(true) {
            self.errors.add(attr, "can't be blank", "blank");
        }
    }

    pub fn validates_presence_of<V>(&mut self, attr: &'static str, value: &Option<V>) {
        if value.is_none() {
            self.errors.add(attr, "can't be blank", "blank");
        }
    }

    pub fn validates_length(&mut self, attr: &'static str, value: &str, opts: LengthOptions) {
        let len = value.len();
        if let Some(min) = opts.minimum {
            if len < min {
                self.errors.add(attr, format!("is too short (minimum is {} characters)", min), "too_short");
            }
        }
        if let Some(max) = opts.maximum {
            if len > max {
                self.errors.add(attr, format!("is too long (maximum is {} characters)", max), "too_long");
            }
        }
    }

    pub fn validates_format(&mut self, attr: &'static str, value: &str, pattern: &regex::Regex) {
        if !pattern.is_match(value) {
            self.errors.add(attr, "is invalid", "invalid");
        }
    }

    pub fn validates_inclusion<V: PartialEq>(&mut self, attr: &'static str, value: &V, allowed: &[V]) {
        if !allowed.contains(value) {
            self.errors.add(attr, "is not included in the list", "inclusion");
        }
    }

    pub fn validates_numericality<N: PartialOrd>(&mut self, attr: &'static str, value: N, opts: NumericalityOptions<N>) {
        if let Some(gt) = opts.greater_than {
            if value <= gt {
                self.errors.add(attr, format!("must be greater than {:?}", gt), "greater_than");
            }
        }
        // ... other numerical validations
    }

    pub fn result(self) -> ValidationResult {
        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(self.errors)
        }
    }
}

/// Options for length validation
pub struct LengthOptions {
    pub minimum: Option<usize>,
    pub maximum: Option<usize>,
    pub is: Option<usize>,
    pub in_range: Option<std::ops::RangeInclusive<usize>>,
}

/// Options for numericality validation
pub struct NumericalityOptions<N> {
    pub greater_than: Option<N>,
    pub greater_than_or_equal_to: Option<N>,
    pub equal_to: Option<N>,
    pub less_than: Option<N>,
    pub less_than_or_equal_to: Option<N>,
    pub other_than: Option<N>,
    pub odd: bool,
    pub even: bool,
    pub only_integer: bool,
}
```

**Uniqueness Validation** (requires database check):

```rust
/// Async validator for database-dependent validations
#[async_trait]
pub trait AsyncValidatable: Validatable {
    /// Run all validations including async ones (uniqueness, etc.)
    async fn validate_async<C: Connection>(&self, conn: &C) -> ValidationResult;
}

impl<T: Validatable> Validator<T> {
    /// Validates uniqueness by querying the database
    pub async fn validates_uniqueness<C, V>(
        &mut self,
        conn: &C,
        attr: &'static str,
        value: &V,
        scope: &[(&str, &dyn ToSql)],
    ) where
        C: Connection,
        V: ToSql,
    {
        // Build query: SELECT EXISTS(SELECT 1 FROM table WHERE attr = $1 AND scope... AND id != $id)
        // If exists, add error
        if self.check_uniqueness(conn, attr, value, scope).await {
            self.errors.add(attr, "has already been taken", "taken");
        }
    }
}
```

**Generated Code Example**:

```rust
// For: validates :email, presence: true, uniqueness: true, format: EMAIL_REGEX
// For: validates :age, numericality: { greater_than: 0 }

impl Validatable for User {
    fn validate(&self) -> ValidationResult {
        let mut v = Validator::new(self);

        // validates :email, presence: true
        v.validates_presence("email", &self.email);

        // validates :email, format: EMAIL_REGEX
        if let Some(ref email) = self.email {
            lazy_static! {
                static ref EMAIL_REGEX: Regex = Regex::new(r"^[^@]+@[^@]+$").unwrap();
            }
            v.validates_format("email", email, &EMAIL_REGEX);
        }

        // validates :age, numericality: { greater_than: 0 }
        if let Some(age) = self.age {
            v.validates_numericality("age", age, NumericalityOptions {
                greater_than: Some(0),
                ..Default::default()
            });
        }

        v.result()
    }
}

#[async_trait]
impl AsyncValidatable for User {
    async fn validate_async<C: Connection>(&self, conn: &C) -> ValidationResult {
        // First run sync validations
        let mut v = Validator::new(self);
        self.validate_sync(&mut v);

        // Then run async validations
        // validates :email, uniqueness: true
        if let Some(ref email) = self.email {
            v.validates_uniqueness(conn, "email", email, &[]).await;
        }

        v.result()
    }
}
```

---

### 4. Persistable

**Purpose**: Wrap save/update/destroy with callbacks, validations, and transactions.

**Rails Equivalent**:
```ruby
user.save        # Runs callbacks, validations, returns false on failure
user.save!       # Runs callbacks, validations, raises on failure
user.update(attrs)
user.destroy
```

**Rust Design**:

```rust
/// Error type for persistence operations
#[derive(Debug)]
pub enum PersistError {
    Validation(ValidationErrors),
    Callback(CallbackError),
    Database(Box<dyn std::error::Error + Send + Sync>),
    RecordNotSaved,
    RecordNotDestroyed,
}

/// Result type for persistence operations
pub type PersistResult<T> = Result<T, PersistError>;

/// Core persistence trait
#[async_trait]
pub trait Persistable: Validatable + Callbacks + DirtyTracking + Sized {
    /// The database adapter type
    type Connection: Connection;

    /// Get the primary key value (None for new records)
    fn id(&self) -> Option<i64>;

    /// Check if this is a new record (not yet persisted)
    fn new_record(&self) -> bool {
        self.id().is_none()
    }

    /// Check if this record has been persisted
    fn persisted(&self) -> bool {
        self.id().is_some()
    }

    /// Save the record (create or update)
    async fn save(&mut self, conn: &Self::Connection) -> PersistResult<bool> {
        self.save_with_options(conn, SaveOptions::default()).await
    }

    /// Save with options (skip validations, etc.)
    async fn save_with_options(
        &mut self,
        conn: &Self::Connection,
        options: SaveOptions,
    ) -> PersistResult<bool> {
        // Transaction wrapper
        conn.transaction(|tx| async move {
            // 1. Run before_validation callbacks
            self.run_before_callbacks(LifecycleEvent::Validation)
                .map_err(PersistError::Callback)?;

            // 2. Run validations (unless skipped)
            if !options.skip_validations {
                self.validate_async(tx).await
                    .map_err(PersistError::Validation)?;
            }

            // 3. Run after_validation callbacks
            self.run_after_callbacks(LifecycleEvent::Validation)
                .map_err(PersistError::Callback)?;

            // 4. Run before_save callbacks
            self.run_before_callbacks(LifecycleEvent::Save)
                .map_err(PersistError::Callback)?;

            let is_new = self.new_record();

            if is_new {
                // 5a. Run before_create callbacks
                self.run_before_callbacks(LifecycleEvent::Create)
                    .map_err(PersistError::Callback)?;

                // 6a. INSERT
                self.insert(tx).await?;

                // 7a. Run after_create callbacks
                self.run_after_callbacks(LifecycleEvent::Create)
                    .map_err(PersistError::Callback)?;
            } else {
                // 5b. Run before_update callbacks
                self.run_before_callbacks(LifecycleEvent::Update)
                    .map_err(PersistError::Callback)?;

                // 6b. UPDATE (only changed attributes)
                self.update_changed(tx).await?;

                // 7b. Run after_update callbacks
                self.run_after_callbacks(LifecycleEvent::Update)
                    .map_err(PersistError::Callback)?;
            }

            // 8. Run after_save callbacks
            self.run_after_callbacks(LifecycleEvent::Save)
                .map_err(PersistError::Callback)?;

            // 9. Mark as persisted (clear dirty tracking)
            self.mark_persisted();

            Ok(true)
        }).await?;

        // 10. Run after_commit callbacks (outside transaction)
        self.run_after_callbacks(LifecycleEvent::Commit)
            .map_err(PersistError::Callback)?;

        Ok(true)
    }

    /// Insert a new record
    async fn insert(&mut self, conn: &Self::Connection) -> PersistResult<()>;

    /// Update only changed attributes
    async fn update_changed(&mut self, conn: &Self::Connection) -> PersistResult<()>;

    /// Update specific attributes
    async fn update_attributes(
        &mut self,
        conn: &Self::Connection,
        attrs: impl Into<Self::Changes>,
    ) -> PersistResult<bool> {
        // Apply changes
        self.apply_changes(attrs.into());
        // Save
        self.save(conn).await
    }

    /// Apply changes from a changeset
    fn apply_changes(&mut self, changes: Self::Changes);

    /// Destroy the record
    async fn destroy(&mut self, conn: &Self::Connection) -> PersistResult<bool> {
        if self.new_record() {
            return Err(PersistError::RecordNotDestroyed);
        }

        conn.transaction(|tx| async move {
            // 1. Run before_destroy callbacks
            self.run_before_callbacks(LifecycleEvent::Destroy)
                .map_err(PersistError::Callback)?;

            // 2. DELETE
            self.delete(tx).await?;

            // 3. Run after_destroy callbacks
            self.run_after_callbacks(LifecycleEvent::Destroy)
                .map_err(PersistError::Callback)?;

            Ok(true)
        }).await?;

        // 4. Run after_commit callbacks
        self.run_after_callbacks(LifecycleEvent::Commit)
            .map_err(PersistError::Callback)?;

        Ok(true)
    }

    /// Delete from database
    async fn delete(&self, conn: &Self::Connection) -> PersistResult<()>;

    /// Reload from database
    async fn reload(&mut self, conn: &Self::Connection) -> PersistResult<()>;
}

/// Options for save operation
#[derive(Default)]
pub struct SaveOptions {
    pub skip_validations: bool,
    pub skip_callbacks: bool,
    pub touch: bool,
}
```

---

### 5. Timestamps

**Purpose**: Automatically manage `created_at` and `updated_at` columns.

**Rails Equivalent**:
```ruby
# Automatic: created_at set on create, updated_at set on create/update
# touch: true on belongs_to cascades updated_at
```

**Rust Design**:

```rust
use chrono::{DateTime, Utc};

/// Trait for models with timestamps
pub trait Timestamps {
    fn created_at(&self) -> Option<DateTime<Utc>>;
    fn updated_at(&self) -> Option<DateTime<Utc>>;
    fn set_created_at(&mut self, time: DateTime<Utc>);
    fn set_updated_at(&mut self, time: DateTime<Utc>);

    /// Called before create to set created_at
    fn stamp_created(&mut self) {
        let now = Utc::now();
        self.set_created_at(now);
        self.set_updated_at(now);
    }

    /// Called before update to set updated_at
    fn stamp_updated(&mut self) {
        self.set_updated_at(Utc::now());
    }

    /// Touch the record (update updated_at only)
    async fn touch<C: Connection>(&mut self, conn: &C) -> PersistResult<()> {
        self.set_updated_at(Utc::now());
        self.save_timestamps(conn).await
    }

    /// Save only timestamp columns
    async fn save_timestamps<C: Connection>(&self, conn: &C) -> PersistResult<()>;
}

/// Macro to auto-implement timestamps
///
/// ```rust
/// #[derive(Timestamps)]
/// struct Post {
///     #[timestamp(created)]
///     created_at: Option<DateTime<Utc>>,
///     #[timestamp(updated)]
///     updated_at: Option<DateTime<Utc>>,
/// }
/// ```
```

---

### 6. Associations

**Purpose**: Define and query relationships between models.

**Rails Equivalent**:
```ruby
user.posts                    # Query all posts
user.posts.where(published: true)  # Scoped query
user.posts.build              # New associated record
user.posts.create(attrs)      # Create and persist
post.author                   # belongs_to lookup
```

**Rust Design**:

```rust
/// Marker traits for association types
pub trait BelongsTo<Parent> {}
pub trait HasOne<Child> {}
pub trait HasMany<Child> {}

/// Association query builder
pub struct AssociationQuery<'a, T, Child> {
    parent: &'a T,
    // Internal query builder state
}

/// Trait for belongs_to associations
#[async_trait]
pub trait BelongsToAssociation<Parent: Persistable>: Sized {
    /// Get the foreign key value
    fn foreign_key(&self) -> Option<i64>;

    /// Set the foreign key
    fn set_foreign_key(&mut self, id: i64);

    /// Load the parent record
    async fn load_parent<C: Connection>(&self, conn: &C) -> PersistResult<Option<Parent>>;

    /// Get cached parent (if loaded)
    fn cached_parent(&self) -> Option<&Parent>;
}

/// Trait for has_many associations
#[async_trait]
pub trait HasManyAssociation<Child: Persistable>: Sized {
    /// Get a query builder for the association
    fn association_query(&self) -> AssociationQuery<'_, Self, Child>;

    /// Load all associated records
    async fn load_all<C: Connection>(&self, conn: &C) -> PersistResult<Vec<Child>>;

    /// Build a new associated record (not saved)
    fn build(&self, attrs: Child::Attributes) -> Child;

    /// Create and save a new associated record
    async fn create<C: Connection>(&self, conn: &C, attrs: Child::Attributes) -> PersistResult<Child>;

    /// Get cached children (if loaded)
    fn cached_children(&self) -> Option<&[Child]>;
}

/// Generated association methods on model
///
/// For `has_many :posts`:
/// ```rust
/// impl User {
///     pub fn posts(&self) -> AssociationQuery<'_, Self, Post> {
///         AssociationQuery::new(self)
///     }
///
///     pub async fn load_posts<C: Connection>(&self, conn: &C) -> PersistResult<Vec<Post>> {
///         Post::where_author_id(self.id.unwrap()).load(conn).await
///     }
///
///     pub fn build_post(&self, attrs: PostAttributes) -> Post {
///         Post::new(PostAttributes {
///             author_id: self.id,
///             ..attrs
///         })
///     }
/// }
/// ```
```

**Through Associations**:

```rust
/// For `has_many :tags, through: :taggings`:
impl User {
    pub async fn load_tags<C: Connection>(&self, conn: &C) -> PersistResult<Vec<Tag>> {
        // SELECT tags.*
        // FROM tags
        // INNER JOIN taggings ON taggings.tag_id = tags.id
        // WHERE taggings.user_id = $1

        Tag::query()
            .inner_join::<Tagging>()
            .filter(Tagging::user_id().eq(self.id.unwrap()))
            .load(conn)
            .await
    }
}
```

**Polymorphic Associations** (closed type set):

```rust
/// For `belongs_to :commentable, polymorphic: true` with closed types
/// Compiler generates:

#[derive(Debug, Clone)]
pub enum Commentable {
    Post(Post),
    Image(Image),
    Video(Video),
}

impl Comment {
    pub fn commentable_type(&self) -> &str {
        &self.commentable_type
    }

    pub fn commentable_id(&self) -> i64 {
        self.commentable_id
    }

    pub async fn load_commentable<C: Connection>(&self, conn: &C) -> PersistResult<Commentable> {
        match self.commentable_type.as_str() {
            "Post" => Ok(Commentable::Post(
                Post::find(conn, self.commentable_id).await?
            )),
            "Image" => Ok(Commentable::Image(
                Image::find(conn, self.commentable_id).await?
            )),
            "Video" => Ok(Commentable::Video(
                Video::find(conn, self.commentable_id).await?
            )),
            other => Err(PersistError::UnknownPolymorphicType(other.to_string())),
        }
    }
}
```

---

### 7. RailsCoercion

**Purpose**: Type coercion matching Rails' behavior (e.g., "1" → 1, "true" → true).

**Rails Equivalent**:
```ruby
# Rails coerces form params automatically:
params[:age] = "25"  # String from form
user.age = params[:age]  # Coerced to Integer 25
```

**Rust Design**:

```rust
/// Trait for Rails-compatible type coercion
pub trait RailsCoerce<T> {
    fn rails_coerce(value: impl AsRef<str>) -> Result<T, CoercionError>;
}

#[derive(Debug)]
pub struct CoercionError {
    pub value: String,
    pub target_type: &'static str,
}

impl RailsCoerce<i32> for i32 {
    fn rails_coerce(value: impl AsRef<str>) -> Result<i32, CoercionError> {
        value.as_ref().parse::<i32>()
            .map_err(|_| CoercionError {
                value: value.as_ref().to_string(),
                target_type: "Integer",
            })
    }
}

impl RailsCoerce<bool> for bool {
    fn rails_coerce(value: impl AsRef<str>) -> Result<bool, CoercionError> {
        match value.as_ref() {
            "true" | "1" | "yes" | "on" => Ok(true),
            "false" | "0" | "no" | "off" | "" => Ok(false),
            other => Err(CoercionError {
                value: other.to_string(),
                target_type: "Boolean",
            }),
        }
    }
}

impl RailsCoerce<f64> for f64 {
    fn rails_coerce(value: impl AsRef<str>) -> Result<f64, CoercionError> {
        value.as_ref().parse::<f64>()
            .map_err(|_| CoercionError {
                value: value.as_ref().to_string(),
                target_type: "Float",
            })
    }
}

// DateTime coercion supports Rails' flexible parsing
impl RailsCoerce<DateTime<Utc>> for DateTime<Utc> {
    fn rails_coerce(value: impl AsRef<str>) -> Result<DateTime<Utc>, CoercionError> {
        // Try multiple formats like Rails does
        let s = value.as_ref();

        // ISO 8601
        if let Ok(dt) = DateTime::parse_from_rfc3339(s) {
            return Ok(dt.with_timezone(&Utc));
        }

        // Rails default format
        if let Ok(dt) = NaiveDateTime::parse_from_str(s, "%Y-%m-%d %H:%M:%S") {
            return Ok(DateTime::from_naive_utc_and_offset(dt, Utc));
        }

        // Date only
        if let Ok(d) = NaiveDate::parse_from_str(s, "%Y-%m-%d") {
            return Ok(DateTime::from_naive_utc_and_offset(
                d.and_hms_opt(0, 0, 0).unwrap(),
                Utc
            ));
        }

        Err(CoercionError {
            value: s.to_string(),
            target_type: "DateTime",
        })
    }
}
```

---

### 8. Enumerable

**Purpose**: Define enum columns with Rails-compatible methods.

**Rails Equivalent**:
```ruby
enum :status, [:draft, :published, :archived]
# Generates: draft?, published?, draft!, published!, scope :draft, etc.
```

**Rust Design**:

```rust
/// Trait for enum columns
pub trait Enumerable: Sized + Copy + Clone + PartialEq {
    /// All possible values
    fn values() -> &'static [Self];

    /// Get the integer value
    fn to_i32(self) -> i32;

    /// Create from integer value
    fn from_i32(value: i32) -> Option<Self>;

    /// Get the string name
    fn to_str(self) -> &'static str;

    /// Create from string name
    fn from_str(value: &str) -> Option<Self>;
}

/// Derive macro generates the enum and all methods
///
/// Input:
/// ```rust
/// #[derive(RailsEnum)]
/// #[rails_enum(column = "status")]
/// enum PostStatus {
///     #[value = 0]
///     Draft,
///     #[value = 1]
///     Published,
///     #[value = 2]
///     Archived,
/// }
/// ```
///
/// Generates on Post:
/// ```rust
/// impl Post {
///     pub fn draft(&self) -> bool { self.status == PostStatus::Draft }
///     pub fn published(&self) -> bool { self.status == PostStatus::Published }
///     pub fn archived(&self) -> bool { self.status == PostStatus::Archived }
///
///     pub fn draft!(&mut self) { self.status = PostStatus::Draft; }
///     pub fn published!(&mut self) { self.status = PostStatus::Published; }
///     pub fn archived!(&mut self) { self.status = PostStatus::Archived; }
/// }
///
/// // Scopes
/// impl Post {
///     pub fn scope_draft() -> impl Scope { where_status(PostStatus::Draft) }
///     pub fn scope_published() -> impl Scope { where_status(PostStatus::Published) }
///     pub fn scope_archived() -> impl Scope { where_status(PostStatus::Archived) }
///
///     pub fn scope_not_draft() -> impl Scope { where_status_not(PostStatus::Draft) }
///     // etc.
/// }
/// ```
```

---

## Crate Structure

```
activerust/
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── dirty_tracking.rs      # DirtyTracking trait + derive macro
│   ├── callbacks.rs           # Callbacks trait + macros
│   ├── validatable.rs         # Validatable trait + validators
│   ├── persistable.rs         # Persistable trait (save/update/destroy)
│   ├── timestamps.rs          # Timestamps trait
│   ├── associations/
│   │   ├── mod.rs
│   │   ├── belongs_to.rs
│   │   ├── has_one.rs
│   │   ├── has_many.rs
│   │   └── through.rs
│   ├── coercion.rs            # RailsCoerce trait
│   ├── enumerable.rs          # Enumerable trait
│   ├── errors.rs              # Error types
│   └── adapters/
│       ├── mod.rs
│       ├── diesel.rs          # Diesel adapter
│       ├── sea_orm.rs         # SeaORM adapter
│       └── sqlx.rs            # SQLx adapter
├── activerust-derive/         # Procedural macros crate
│   ├── Cargo.toml
│   └── src/
│       ├── lib.rs
│       ├── dirty_tracking.rs
│       ├── callbacks.rs
│       ├── validatable.rs
│       └── enumerable.rs
└── tests/
    ├── dirty_tracking_tests.rs
    ├── callbacks_tests.rs
    ├── validations_tests.rs
    └── integration_tests.rs
```

---

## Usage Example

Here's how a compiled Rails model would look:

**Original Rails**:
```ruby
class User < ApplicationRecord
  has_many :posts
  belongs_to :organization, optional: true

  validates :email, presence: true, uniqueness: true
  validates :name, length: { minimum: 2, maximum: 100 }

  before_save :normalize_email, if: :email_changed?
  after_create :send_welcome_email

  enum :status, [:active, :suspended, :deleted]

  scope :active_users, -> { where(status: :active) }

  private

  def normalize_email
    self.email = email.downcase.strip
  end

  def send_welcome_email
    # TODO: business logic
  end
end
```

**Generated Rust**:
```rust
use activerust::prelude::*;
use diesel::prelude::*;

#[derive(
    Debug, Clone,
    Queryable, Insertable, AsChangeset,  // Diesel
    DirtyTracking, Callbacks, Validatable, Timestamps,  // activerust
)]
#[diesel(table_name = users)]
pub struct User {
    pub id: Option<i64>,
    pub email: Option<String>,
    pub name: Option<String>,
    pub organization_id: Option<i64>,
    pub status: UserStatus,
    pub created_at: Option<DateTime<Utc>>,
    pub updated_at: Option<DateTime<Utc>>,

    // Dirty tracking state (generated by derive)
    #[diesel(skip)]
    _dirty: UserDirtyState,
}

// Enum for status column
#[derive(Debug, Clone, Copy, PartialEq, Eq, RailsEnum, DbEnum)]
#[rails_enum(column = "status")]
pub enum UserStatus {
    #[value = 0]
    Active,
    #[value = 1]
    Suspended,
    #[value = 2]
    Deleted,
}

// Validations implementation
impl Validatable for User {
    fn validate(&self) -> ValidationResult {
        let mut v = Validator::new(self);

        // validates :email, presence: true
        v.validates_presence("email", &self.email);

        // validates :name, length: { minimum: 2, maximum: 100 }
        if let Some(ref name) = self.name {
            v.validates_length("name", name, LengthOptions {
                minimum: Some(2),
                maximum: Some(100),
                ..Default::default()
            });
        }

        v.result()
    }
}

#[async_trait]
impl AsyncValidatable for User {
    async fn validate_async<C: Connection>(&self, conn: &C) -> ValidationResult {
        let mut v = Validator::new(self);

        // Run sync validations
        if let Err(e) = self.validate() {
            v.merge_errors(e);
        }

        // validates :email, uniqueness: true
        if let Some(ref email) = self.email {
            v.validates_uniqueness(conn, "email", email, &[]).await;
        }

        v.result()
    }
}

// Callbacks implementation
impl Callbacks for User {
    fn callbacks() -> &'static [Callback<Self>] {
        static CALLBACKS: &[Callback<User>] = &[
            Callback {
                name: "normalize_email",
                timing: CallbackTiming::Before,
                event: LifecycleEvent::Save,
                condition: Some(|u| u.email_changed()),
                action: |u| u.normalize_email(),
            },
            Callback {
                name: "send_welcome_email",
                timing: CallbackTiming::After,
                event: LifecycleEvent::Create,
                condition: None,
                action: |u| u.send_welcome_email(),
            },
        ];
        CALLBACKS
    }
}

// Callback methods
impl User {
    fn normalize_email(&mut self) -> CallbackResult {
        if let Some(ref email) = self.email {
            self.email = Some(email.to_lowercase().trim().to_string());
        }
        Ok(())
    }

    fn send_welcome_email(&mut self) -> CallbackResult {
        // TODO: business logic
        todo!("Implement send_welcome_email")
    }
}

// Association methods
impl User {
    pub fn posts(&self) -> AssociationQuery<'_, Self, Post> {
        AssociationQuery::new(self)
    }

    pub async fn load_posts(&self, conn: &impl Connection) -> PersistResult<Vec<Post>> {
        Post::where_author_id(self.id.unwrap()).load(conn).await
    }

    pub fn build_post(&self, attrs: PostAttributes) -> Post {
        Post::new(PostAttributes {
            author_id: self.id,
            ..attrs
        })
    }

    pub fn organization(&self) -> Option<&Organization> {
        self._cached_organization.as_ref()
    }

    pub async fn load_organization(&self, conn: &impl Connection) -> PersistResult<Option<Organization>> {
        match self.organization_id {
            Some(id) => Organization::find(conn, id).await.map(Some),
            None => Ok(None),
        }
    }
}

// Enum convenience methods
impl User {
    pub fn active(&self) -> bool { self.status == UserStatus::Active }
    pub fn suspended(&self) -> bool { self.status == UserStatus::Suspended }
    pub fn deleted(&self) -> bool { self.status == UserStatus::Deleted }

    pub fn make_active(&mut self) { self.set_status(UserStatus::Active); }
    pub fn make_suspended(&mut self) { self.set_status(UserStatus::Suspended); }
    pub fn make_deleted(&mut self) { self.set_status(UserStatus::Deleted); }
}

// Scopes
impl User {
    pub fn active_users() -> impl Scope<User> {
        UserScope::where_status(UserStatus::Active)
    }

    pub fn scope_active() -> impl Scope<User> {
        UserScope::where_status(UserStatus::Active)
    }

    pub fn scope_suspended() -> impl Scope<User> {
        UserScope::where_status(UserStatus::Suspended)
    }

    pub fn scope_not_deleted() -> impl Scope<User> {
        UserScope::where_status_not(UserStatus::Deleted)
    }
}
```

---

## Semantic Gap Analysis

### What activerust Provides vs Rails

| Feature | Rails | activerust | Gap |
|---------|-------|------------|-----|
| Dirty tracking | Automatic | Derive macro | None |
| Callbacks | `throw(:abort)` halts | `Result<(), Error>` halts | Explicit return |
| Validations | Declarative DSL | Trait methods | More verbose |
| Uniqueness validation | `validates :x, uniqueness: true` | Async + DB query | Same behavior |
| Associations (basic) | `has_many :posts` | Methods + query builder | Same behavior |
| Associations (through) | Automatic JOINs | Explicit JOINs | Same behavior |
| Polymorphic | Open type set | Closed enum | Requires type list |
| Lazy loading | Automatic | Explicit `load_*` | More explicit |
| Transactions | Implicit | Explicit | Same behavior |
| Timestamps | Automatic | Derive macro | None |
| Enums | `enum :col, [...]` | Derive macro | None |
| Type coercion | Automatic | `RailsCoerce` trait | Explicit |

### What Remains Manual

1. **Business logic in callbacks** — The `todo!()` markers
2. **Custom validations** — The `validate :custom_method` bodies
3. **Controller actions** — The request handling logic
4. **Background jobs** — Sidekiq/Resque equivalents
5. **Mailers** — Email sending logic

---

## Next Steps

1. **Document 12**: Query Builder Algebra — How scopes compose, Arel → Rust mapping
2. **Document 13**: Multi-Pass Architecture — Query-based compiler design with Salsa
3. **Prototype**: Build `activerust` v0.1 with DirtyTracking + Callbacks + Validations

---

## References

- [Diesel ORM](https://diesel.rs/) — Rust ORM used as foundation
- [SeaORM](https://www.sea-ql.org/SeaORM/) — Alternative async ORM with ActiveModel pattern
- [Rails ActiveRecord Source](https://github.com/rails/rails/tree/main/activerecord) — Reference implementation
- [Loco.rs](https://loco.rs/) — "Rails for Rust" framework (validation patterns)
